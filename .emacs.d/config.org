* Configuration
<<babel-init>>
** OS X
#+begin_src emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (progn
      (setq with-editor-emacsclient-executable 
            "/usr/local/Cellar/emacs/25.1/bin/emacsclient")
      (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
      (setenv "SHELL" "/bin/zsh")
      (setq exec-path (append exec-path '("/usr/local/bin")))

      (setq default-input-method "MacOSX")

      (setq mac-command-modifier 'meta
            mac-option-modifier nil
            mac-allow-anti-aliasing t
            mac-command-key-is-meta t)))

#+end_src
** Common stuff
*** Global settings
#+begin_src emacs-lisp :tangle yes
  ;;; -*- lexical-binding: t; -*-

  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)

  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (package-initialize)

  (setq inhibit-startup-screen t
        sentence-end-double-space nil
        ad-redefinition-action 'accept
        backup-directory-alist '(("." . "~/.emacs.d/backups"))
        auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list" t))
        delete-old-versions -1
        version-control t
        vc-make-backup-files t)

  (global-unset-key (kbd "C-z"))
  (bind-key (kbd "C-S-k") 'kill-whole-line)

  (blink-cursor-mode 0)
  (global-hl-line-mode 1)

  (fset 'yes-or-no-p 'y-or-n-p)

  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

#+end_src

*** Color theme
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")

    (when window-system
      (load-theme 'gotham t))

    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (load-theme 'gotham t)
                    (scroll-bar-mode -1)
                    (powerline-reset))))

  (use-package powerline
    :ensure t
    :init (powerline-center-theme))

#+end_src
*** Custom functions
#+begin_src emacs-lisp :tangle yes
  ;; Custom functions
  (defvar my-app-config-files
    '((emacs        . "~/.emacs.d/config.org")
      (zshrc        . "~/.zshrc")
      (zprofile     . "~/.zprofile")
      (ssh          . "~/.ssh/config")
      (sshd         . "/sudo::/etc/ssh/sshd_config")
      (X11          . "/sudo::/etc/X11/xorg.conf")
      (i3           . "~/.i3/config")
      (bashrc       . "~/.bashrc")
      (git          . "~/.gitconfig")
      (pylint       . "~/.pylintrc")
      (bash_profile . "~/.bash_profile")))

  (defun my-edit-config ()
    "Visit or switch to applications config file."
    (interactive)
    (let ((application (completing-read "Select application: " my-app-config-files)))
      (find-file (cdr (assoc (intern application) my-app-config-files)))))

  (bind-key (kbd "C-c <f9>") 'my-edit-config)

  (defun my-smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'my-smarter-move-beginning-of-line)

  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (global-set-key (kbd "C-c e") 'eval-and-replace)

  (defun my-vsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (if (= prefix 1)
      (switch-to-next-buffer)))
  (defun my-hsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (if (= prefix 1) (switch-to-next-buffer)))
  (bind-key "C-x 2" 'my-vsplit-last-buffer)
  (bind-key "C-x 3" 'my-hsplit-last-buffer)



#+end_src

*** Helm
#+begin_src emacs-lisp :tangle yes
  (use-package helm
    :ensure helm
    :diminish helm-mode
    :init (setq helm-candidate-number-limit           100
                helm-idle-delay                       0.0
                helm-input-idle-delay                 0.01
                helm-quick-update                     t
                helm-M-x-requires-pattern             nil
                helm-ff-skip-boring-files             t
                helm-move-to-line-cycle-in-source     t
                helm-split-window-in-side-p           t
                helm-ff-search-library-in-sexp        t
                helm-scroll-amount                    8
                helm-ff-file-name-history-use-recentf t)
    :config (progn
              (require 'helm-config)
              (global-set-key (kbd "C-c h") 'helm-command-prefix)
              (global-unset-key (kbd "C-x c"))
              (helm-mode 1)
              (use-package helm-swoop
                :bind (("C-S-s"   . helm-swoop)
                       ("M-i"     . helm-swoop)
                       ("M-s s"   . helm-swoop)
                       ("M-s M-s" . helm-swoop)
                       ("M-I"     . helm-swoop-back-to-last-point)
                       ("C-c M-i" . helm-multi-swoop)
                       ("C-x M-i" . helm-multi-swoop-all)
                       :map helm-swoop-map
                       ("M-i"     . helm-multi-swoop-all-from-helm-swoop))))
    :bind (("C-c h m" . helm-mini)
           ("C-h a"   . helm-apropos)
           ("C-x C-b" . helm-buffers-list)
           ("C-x b"   . helm-buffers-list)
           ("M-y"     . helm-show-kill-ring)
           ("M-x"     . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("M-s o"   . helm-occur)
           ("C-c h s" . helm-swoop)
           :map helm-map
           ("[tab]"   . helm-execute-persistent-action)
           ("C-i"     . helm-execute-persistent-action)
           ("C-z"     . helm-select-action)))
#+end_src
*** Ace-window
#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :init (setq aw-dispatch-always 1)
    :bind ("M-รถ" . ace-window))
#+end_src
*** Expand-region
#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :ensure expand-region
    :config (pending-delete-mode 1)
    :bind ("C-=" . er/expand-region))
#+end_src
** Programming
*** Global programming settings
#+begin_src emacs-lisp :tangle yes
  (use-package nlinum-relative
    :ensure t
    :config
    (nlinum-relative-setup-evil)
    (setq nlinum-relative-redisplay-delay 0)
    (add-hook 'prog-mode-hook #'nlinum-relative-mode))

  (use-package comment-dwim-2
    :ensure t)

  (use-package magit
    :ensure t
    :defer t
    :config
    (setq magit-branch-arguments nil)
    :bind
    (("C-c g" . magit-status)))

  (global-set-key (kbd "C-#") 'comment-or-uncomment-region)
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 2)
#+end_src
*** Flycheck
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :init (add-hook 'prog-mode-hook #'flycheck-mode)
    :diminish
    :config
    (setq flycheck-standard-error-navigation t
          flycheck-deferred-syntax-check nil
          flycheck-completion-system nil))

  (add-hook 'flycheck-mode-hook
            (lambda ()
              (evil-define-key 'normal flycheck-mode-map (kbd "]e") 'flycheck-next-error)
              (evil-define-key 'normal flycheck-mode-map (kbd "]e") 'flycheck-previous-error)))

#+end_src
*** Yasnippet
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :mode ("/\\.emacs\\.d/snippets/" . snippet-mode)
    :config (yas-global-mode 1))
#+end_src
*** Projectile
#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :diminish projectile-mode
    :init (setq projectile-keymap-prefix (kbd "C-c p")
                projectile-completion-system 'default
                projectile-enable-caching t)
    :config (progn (projectile-global-mode)
                   (use-package helm-projectile
                     :ensure helm-projectile
                     :defer t)))
#+end_src
*** Company
#+begin_src emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :diminish company-mode
    :init (progn
            (add-hook 'prog-mode-hook 'company-mode)
            (add-hook 'LaTeX-mode-hook 'company-mode))
    :config (company-quickhelp-mode 1))

#+end_src
*** Smartparens
#+begin_src emacs-lisp :tangle yes
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :config
    (require 'smartparens-config)
    (smartparens-global-mode 1)
    (show-smartparens-global-mode 1))
#+end_src
*** Python
#+begin_src emacs-lisp :tangle yes

  (defun my-jedi-show-doc (buffer)
    (with-current-buffer buffer
      (message (buffer-string))))

  (setq jedi:doc-display-buffer 'my-jedi-show-doc)

  (use-package virtualenvwrapper
    :ensure t
    :config
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location (expand-file-name "~/.virtualenvs")))
  (use-package python
    :load-path "pydebug"
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode)
    :init (progn
            (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions)
                  gud-pdb-command-name "python -m pdb")
            (use-package pydebug))
    :config
    (define-coding-system-alias 'UTF-8 'utf-8)
    (global-unset-key (kbd "<f11>"))
    
    ;; (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook
              (lambda ()
                (progn (set (make-local-variable 'company-backends) '(company-jedi))
                       (jedi:install-server))))
    :bind (
           :map comint-mode-map
           ("<f5>"     . pydebug-run-realgud-current-file)
           ("C-<f5>"   . pydebug-quit-realgud)
           ("<f9>"     . realgud:cmd-break)
           ("S-<f9>"   . realgud:cmd-clear)
           ("C-<f9>"   . realgud:cmd-until)
           ("<f10>"    . realgud:cmd-next)
           ("<f11>"    . realgud:cmd-step)
           ("C-<f11>"  . realgud:cmd-continue)
           :map python-mode-map
           ("<f5>"     . pydebug-run-realgud-current-file)
           ("C-<f5>"   . pydebug-quit-realgud)
           ("<f9>"     . realgud:cmd-break)
           ("S-<f9>"   . realgud:cmd-clear)
           ("C-<f9>"   . realgud:cmd-until)
           ("<f10>"    . realgud:cmd-next)
           ("<f11>"    . realgud:cmd-step)
           ("C-<f11>"  . realgud:cmd-continue)
           ("C-c C-c"  . pydebug-eval-in-minibuffer)))
#+end_src
*** C/C++
*** XML
*** LaTeX
** Evil
#+begin_src emacs-lisp :tangle yes
  (defun my-config-evil-leader ()
    "Configure evil leader mode."
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      ","  (lambda () (interactive) (ansi-term (getenv "SHELL")))
      "."  'mode-line-other-buffer
      "-"  'projectile-find-file
      "_"  'projectile-switch-project
      ":"  'eval-expression
      "aa" 'align-regexp
      "e"  'eval-last-sexp
      "a=" 'my-align-single-equals
      "b"  'helm-mini             ;; Switch to another buffer
      "B"  'magit-blame-toggle
      "c"  'comment-dwim-2
      "d"  'kill-this-buffer
      "D"  'open-current-line-in-codebase-search
      "f"  'helm-imenu            ;; Jump to function in buffer
      "g"  'magit-status
      "h"  'fontify-and-browse    ;; HTML-ize the buffer and browse the result
      "l"  'whitespace-mode       ;; Show invisible characters
      "nn" 'air-narrow-dwim       ;; Narrow to region and enter normal mode
      "nw" 'widen
      "o"  'delete-other-windows  ;; C-w o
      "O"  'helm-occur
      "pd" 'jedi:goto-definition
      "p?" 'jedi:show-doc
      "s"  'ag-project            ;; Ag search from project's root
      "r"  'chrome-reload
      "R"  (lambda () (interactive) (font-lock-fontify-buffer) (redraw-display))
      "S"  'delete-trailing-whitespace
      "t"  'gtags-reindex
      "T"  'gtags-find-tag
      "w"  'save-buffer
      "x"  'helm-M-x
      "y"  'yank-to-x-clipboard)

    (defun magit-blame-toggle ()
      "Toggle magit-blame-mode on and off interactively."
      (interactive)
      (if (and (boundp 'magit-blame-mode) magit-blame-mode)
          (magit-blame-quit)
        (call-interactively 'magit-blame))))

  (defun is-empty-line-p ()
    (string-match "^[[:blank:]]*$"
          (buffer-substring (line-beginning-position)
                            (line-end-position))))

  (defun my-complete-or-indent ()
    "On an empty (only whitespace) line, do an indent, otherwise auto-complete."
    (interactive)
    (if (is-empty-line-p)
        (indent-for-tab-command)
      (company-complete)))

  (defun my-config-evil ()
    "Configure evil mode."

    ;; Use Emacs state in these additional modes.
    (dolist (mode '(ag-mode
                    flycheck-error-list-mode
                    git-rebase-mode
                    octopress-mode
                    octopress-server-mode
                    octopress-process-mode
                    sunshine-mode
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode))

    (delete 'term-mode evil-insert-state-modes)

    ;; Use insert state in these additional modes.
    (dolist (mode '(twittering-edit-mode
                    magit-log-edit-mode))
      (add-to-list 'evil-insert-state-modes mode))

    (add-to-list 'evil-buffer-regexps '("\\*Flycheck"))

    (evil-add-hjkl-bindings occur-mode-map 'emacs
      (kbd "/")       'evil-search-forward
      (kbd "n")       'evil-search-next
      (kbd "N")       'evil-search-previous
      (kbd "C-d")     'evil-scroll-down
      (kbd "C-u")     'evil-scroll-up
      (kbd "C-w C-w") 'other-window)

    ;; Global bindings.
    (define-key evil-normal-state-map (kbd "<down>")  'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "<up>")    'evil-previous-visual-line)
    (define-key evil-normal-state-map (kbd "-")       'helm-find-files)
    (define-key evil-normal-state-map (kbd "C-]")     'gtags-find-tag-from-here)
    (define-key evil-normal-state-map (kbd "g/")      'occur-last-search)
    (define-key evil-normal-state-map (kbd "[i")      'show-first-occurrence)
    (define-key evil-normal-state-map (kbd "S-SPC")   'air-pop-to-org-agenda)
    (define-key evil-insert-state-map (kbd "C-e")     'end-of-line) ;; I know...

    (evil-define-key 'normal global-map (kbd "C-p")   'helm-projectile)
    (evil-define-key 'normal global-map (kbd "C-S-p") 'helm-projectile-switch-project)
    (evil-define-key 'insert global-map (kbd "s-d")   'eval-last-sexp)
    (evil-define-key 'normal global-map (kbd "s-d")   'eval-defun)



    (defun minibuffer-keyboard-quit ()
      "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
      (interactive)
      (if (and delete-selection-mode transient-mark-mode mark-active)
          (setq deactivate-mark  t)
        (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
        (abort-recursive-edit)))

    ;; Make escape quit everything, whenever possible.
    (define-key evil-normal-state-map [escape] 'keyboard-quit)
    (define-key evil-visual-state-map [escape] 'keyboard-quit)
    (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
    (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
    (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
    (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
    (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)

    ;; Tab launces company-complete only in insert-state
    (define-key evil-insert-state-map (kbd "<tab>") 'my-complete-or-indent)

    (defun evil-visual-line--mark-org-element-when-heading (&rest args)
      "When marking a visual line in Org, mark the current element.

  This function is used as a `:before-while' advice on
  `evil-visual-line'; if the current mode is derived from Org Mode and
  point is resting on an Org heading, mark the whole element instead of
  the line. ARGS are passed to `evil-visual-line' when text objects are
  used, but this function ignores them."
      (interactive)
      (if (and (derived-mode-p 'org-mode)
               (org-on-heading-p))
          (not (org-mark-element))
        t))

    (advice-add 'evil-visual-line :before-while #'evil-visual-line--mark-org-element-when-heading))


  (defun my-apply-evil-other-package-configs ()
    "Apply evil-dependent settings specific to other packages."

    (defun next-conflict-marker ()
      (interactive)
      (evil-next-visual-line)
      (if (not (search-forward-regexp "\\(>>>>\\|====\\|<<<<\\)" (point-max) t))
          (evil-previous-visual-line))
      (move-beginning-of-line nil))

    (defun previous-conflict-marker ()
      (interactive)
      (search-backward-regexp "\\(>>>>\\|====\\|<<<<\\)" (point-min) t)
      (move-beginning-of-line nil))

    ;; PHP
    (evil-define-key 'normal php-mode-map (kbd "]n") 'next-conflict-marker)
    (evil-define-key 'normal php-mode-map (kbd "[n") 'previous-conflict-marker)
    (evil-define-key 'visual php-mode-map (kbd "]n") 'next-conflict-marker)
    (evil-define-key 'visual php-mode-map (kbd "[n") 'previous-conflict-marker)

    ;; Dired
    (evil-define-key 'normal dired-mode-map (kbd "C-e") 'dired-toggle-read-only))

  (defmacro define-evil-or-global-key (key def &optional state)
    "Define a key KEY with DEF in an Evil map, or in the global map.

  If the Evil map for STATE is defined (or `normal' if STATE is not
  provided) the key will be defined in that map.  Failing that, it will
  be defined globally.

  Note that STATE should be provided as an unquoted symbol.

  This macro provides a way to override Evil mappings in the appropriate
  Evil map in a manner that is compatible with environments where Evil
  is not used."
    (let* ((evil-map-name (if state
                              (concat "evil-" (symbol-name state) "-state-map")
                            "evil-normal-state-map"))
           (map (if (boundp (intern evil-map-name))
                    (intern evil-map-name)
                  global-map)))
      `(define-key ,map ,key ,def)))

  (use-package evil
    :ensure t
    :commands (evil-mode evil-define-key)
    :config
    (add-hook 'evil-mode-hook 'my-config-evil)

    (use-package evil-leader
      :ensure t
      :config
      (global-evil-leader-mode 1)
      (my-config-evil-leader))

    (use-package evil-surround
      :ensure t
      :config
      (global-evil-surround-mode))

    (use-package evil-indent-textobject
      :ensure t)
    (use-package evil-magit
      :ensure t)
    (use-package key-chord
      :ensure t
      :config
      (key-chord-mode 1)
      (key-chord-define evil-insert-state-map "jk" 'evil-normal-state))
    (evil-mode 1)
    (my-apply-evil-other-package-configs))


#+end_src
